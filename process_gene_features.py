#!/usr/bin/python3

import argparse, re, sys, logging 
from datetime import datetime
import statistics as st
import pysam
import random
from Bio import SeqIO

__author__="Hubert DENISE, R.Durbin group, Dpt of Genetics, Cambridge. Nov 2020"

'''
Script usage: ./process_gene_features.py chromosome<X>_features
This script will process 5 input files to extract the Cm probability for the features in relation to the CpG islands  identified in the chromosome <X>.

The 5 input files are:
  - chromosome<X>_features: gene feature file derived from the Ensembl gff for fAstCal1.2
    The format is <feature> <name> <strand> <start> <end>: 
    gene ID=gene:ENSACLG00000000002;Name=lto1;biotype=protein_coding;description=LTO1 maturation factor of ABCE1 [Source:ZFIN%3BAcc:ZDB-GENE-030729-33];gene_id=ENSACLG00000000002;logic_name=ensembl;version=1 - 19687 21631
    mRNA ID=transcript:ENSACLT00000000002;Parent=gene:ENSACLG00000000002;Name=lto1-201;biotype=protein_coding;transcript_id=ENSACLT00000000002;version=1 - 19687 21631
  - CpG_chr<X>: CpG island file derived from the output of CpGProd_linux for each chromosome. The CpG islands for each chromosome were named CpG<X> where X is an incremental integer starting at 1
    The format is <start> <end> <name>: 
    1 912 CpG1
    1429 2152 CpG2
  - fastq_mapping_sorted.bam: binary version of the sam file generated by mapping of the fastq reads to the genome with minimap2 
  - two pre-processed files: one containing the position of CG dinucleotides in each reads of the fastq files obtained after basecalling and a second one containing the corresponding Cm probability at these positions. They were obtained by running preprocess_modif_tables.py. Both files are in fasta like format:
   + Preprocessed_Table_pos:
     >4926de3b-22bf-45fe-8234-7f58eb002bc5
     37, 196, 243, 389, 714
     >591e2997-d484-4ba2-a129-d027f4d18e6b
     506, 510, 530, 549, 552, 569, 606, 629, 679, 701, ...
   + Preprocessed_Table_mod:
    >001540a0-54e5-41fb-a00a-08db26ff5e62
    254, 252, 205, 215, 254, 242, 252, 252, 253, 228, 254, 254, 250, 234, 210, 85, 253, 251, 167, 153,.... 
The path to the folders to access these files are provided into the contig file: process.config

The time for each step will be captured into the process_chr<X>.log file.

It will produce a number of files ouput:
   - chr<X>_CpG_<feature>_results.tsv lists the feature name, length then Cm probability, number of CG dinucleotide and cumulative length of regions within and outside the CpG islands
     feature length  Cm_noCpG        nberCG_noCpG    length_noCpG    Cm_inCpG        nberCG_inCpG    length_inCpG
     ENSACLG00000020698      864     46963.6 447.1   32613.2 0.0     0.0     0.0 ...
   - chr<X>_CpG_<feature>_summary.tsv lists the feature name, length then Cm probability for the feature and regions within and outside the CpG islands normalised by the feature length
     feature length  Cm_per_feature_length   Cm_noCpG_per_feature_length     Cm_inCpG_per_feature_length
     ENSACLG00000020698      84     622.1   1244.2  0 ...
   - chr<X>_feature_results.tsv summarize the results for each type of feature across all the chromosome
     feature total_number    mean_length     mean_prob       mean_prob/length        noCpG_mean_prob noCpG_mean_length       noCpG_mean_CGcount      features_with_CpG       inCpG_mean_length       inCpG_mean_CGcount
     PROMOTER        2       254.0   27921.8 219.9   27780.6 16426.9 240.7   141.1   141.0   3.0
     5prime_UTR      2       3114.0  35300.8 22.7    34957.3 14507.7 268.0   343.5   152.2   3.8 ...
   - Cm_chr<X>.bed list the coodinates of the features and their Cm probabilities 
     chr1    19687   21573   4341.4
     chr1    21631   78636   118097.4 ...
   - Cm_inCpG_chr<X>.bed list the coodinates of the features and the Cm probabilities associated with the CpG islands regions
     chr1    19687   21573   3489.5
     chr1    21631   78636   99099.0
The path to the folders to store these files are also provided into the contig file: process.config
'''

def parse_genefile(file):
    '''
    function to parse the file gene_features/chromosome<X>_features.
    The format of this file is <feature_type> <feature_name> <strand> <start_po> <end_pos>
    The output format is a dictionary with feature as keys and nested dictionary with feature_id as keys and list of start and end position for each feature:
      {'5gene' : {'gene_id1':[start, end], 'gene_id2':[start, end]... }, '5mRNA':{'mRNA1':[start, end], 'mRNA2':[start, end],...}, ...}
    model used:
            |--------------------------gene-----------------------------|
      model .   |-------------------mRNA----------------------------|   .
            .   .   |-5UTR-|  |--------CDS-----------|  |-3UTR-|    .   .
            .   .             .                      .              .   .
             ___ ____________ _______________________ ______________ ____...
     feature 5gene   5mRNA             CDS                3mRNA      3gene b  

    '''
    logging.info("Opening feature file")
    logging.info("  "+str(datetime.now()))
    feature_dic={}
    feature_dic['5gene']={}
    feature_dic['3gene']={}
    feature_dic['5mRNA']={}
    feature_dic['3mRNA']={}
    feature_dic['CDS']={}
    between_count=0
    feature_dic["between"]={}
    feature_dic["between"][str(between_count)]=[1, 1]
    for line in open(path_dic["feature_folder"] + file, "r"):
        line=line.rstrip()
        dataline=line.split()
        strand=dataline[-3]
        start=int(dataline[-2])
        end=int(dataline[-1])
        name=dataline[1].split(";")[0].split(":")[1]
        cds_flag=0
        #only considering 3 types of features
        if dataline[0] in ['gene', 'mRNA', 'CDS']:
           if dataline[0] == 'gene':
              if strand=="+":
                 feature_dic['5gene'][name]=[start, end]
              else:
                 feature_dic['3gene'][name]=[start, end]
              between_count+=1
              feature_dic["between"][str(between_count)]=[end, end]
              feature_dic["between"][str(between_count - 1)][0]=start   
           if dataline[0]== 'mRNA':
              gene_name=dataline[1].split(";")[1].split(":")[1]
              if strand=="+":
                 feature_dic['5gene'][gene_name][1]=start 
                 feature_dic['5mRNA'][name]=[start, end]
              else:
                 feature_dic['3gene'][gene_name][1]=start 
                 feature_dic['3mRNA'][name]=[start, end]
           if dataline[0]== 'CDS':
              mRNA_name=dataline[1].split(";")[1].split(":")[1]
              if name in feature_dic['CDS']:
                 feature_dic['CDS'][name][1]=start
              else:
                 feature_dic['CDS'][name]=[start, end]
                 if strand=="+":
                    feature_dic['5mRNA'][mRNA_name][1]=end
                 else:
                    feature_dic['3mRNA'][mRNA_name][1]=start
    logging.info("  "+str(datetime.now()))
    logging.info("feature file read and processed\n")
    return feature_dic

def get_reads_per_feature(feature_dic, mod_dic, pos_dic, CpG_dic):
   '''
   this script will return a dictionary  ex {'5gene':{'name_read1:{'noCpG':[list of CG probability],'inCpG': [list of CG probability]}, {'name_read2:{'noCpG':[list of CG probability],'inCpG': [list of CG probability]}, ...}}, {'5mRNA':{....}, ...}}
   '''
   logging.info("Starting get_reads_per_feature")
   logging.info("  "+str(datetime.now()))
   prob_res={}
   #the line below is only used for testing
   #feature_dic={'5gene': {'ENSACLG00000020698': [[32873740, 32874604], []], 'ENSACLG00000008971': [[23856159, 23856667], ['CpG1541']]}, '3gene': {'ENSACLG00000006950': [[4463837, 4477631], ['CpG404','CpG403']]}, '5mRNA': {'ENSACLT00000000003': [[78636, 80433], []], 'ENSACLT00000000010': [[155986, 162214], ['CpG18', 'CpG19']]}, '3mRNA': {'ENSACLT00000015888': [[6373039, 6375498], []]}, 'CDS': {'ENSACLP00000000002': [[19687, 21573], ['CpG5']], 'ENSACLP00000000003': [[79235, 80433], ['CpG10']]}, 'between': {'1':[[21631, 78636], ['CpG8', 'CpG9', 'CpG6', 'CpG7']], '2':[[83577, 85876], ['CpG11']]}}
   bamfile = pysam.AlignmentFile(path_dic["bam_folder"] + "fastq_mapping_sorted.bam", "rb")
   for feat in feature_dic:
      if feat not in prob_res:
        prob_res[feat]={}
      for entry in feature_dic[feat]:
         prob_res[feat][entry]={}
         start=feature_dic[feat][entry][0][0]
         end=feature_dic[feat][entry][0][1]
         CpG_list=feature_dic[feat][entry][1]
         #get coordinate of CpG islands
         CpG_coord_list=[[CpG_dic[x][0], CpG_dic[x][1]] for x in CpG_list]
         iter = bamfile.fetch("chr1", start, end)
         prob_res[feat][entry]['length']=0
         for read in iter:
            seq_name=str(read.query_name)
            prob_res[feat][entry][seq_name]={}
            seq_align_start= int(read.query_alignment_start) #read coord
            seq_align_end = int(read.query_alignment_end) #read coord
            chr_align_start= int(read.reference_start) #corresponding chr coord
            chr_align_end = int(read.reference_end) #corresponding chr coord
            read_length=chr_align_end -  chr_align_start
            align_flag=int(read.flag)
            seq = str(read.query_alignment_sequence) #just the portion of the sequence which is aligned
            if seq_name in pos_dic:
               all_CG_pos=pos_dic[seq_name]
               prob=[mod_dic[seq_name][x] for x in range(len(mod_dic[seq_name])) if pos_dic[seq_name][x] >= seq_align_start and pos_dic[seq_name][x] <= seq_align_end]
               CG_pos=[x for x in all_CG_pos if x >= seq_align_start and x <= seq_align_end]
               #extract probability correspond to CG in CpG islands and then the remaining sequences of the features
               if len(CpG_list) > 0:
                 CpG_allCG_index=[]
                 for CpG_index in range(len(CpG_coord_list)):
                    start_CpG=CpG_coord_list[CpG_index][0] #chr coord
                    end_CpG=CpG_coord_list[CpG_index][1]  #chr coord
                    length_CpG=end_CpG - start_CpG
                    read_start_CpG=start_CpG -chr_align_start  #transform in read coord
                    read_end_CpG= end_CpG - chr_align_start   #transform in read coord
                    #get the index of the CG in the CpG island
                    CpG_CG_index=[x for x in range(len(prob)) if CG_pos[x] >= read_start_CpG and CG_pos[x] <= read_end_CpG] 
                    CpG_allCG_index+=CpG_CG_index
                    #get the probability corresponding to the CpG index
                    prob_CpG_list=[prob[x] for x in CpG_CG_index]
                    if 'inCPG' in prob_res[feat][entry][seq_name]:
                       prob_res[feat][entry][seq_name]['inCpG'][0][0]+=prob_CpG_list
                       prob_res[feat][entry][seq_name]['inCpG'][0][1]+=length_CpG
                    else:
                       prob_res[feat][entry][seq_name]['inCpG']=[prob_CpG_list]
                       prob_res[feat][entry][seq_name]['inCpG'].append(length_CpG)                  
                 noCpG_CG_index=[x for x in range(len(CG_pos)) if x not in CpG_allCG_index] 
                 prob_res[feat][entry][seq_name]['noCpG']=[[prob[x] for x in noCpG_CG_index]]
                 prob_res[feat][entry][seq_name]['noCpG'].append(read_length - prob_res[feat][entry][seq_name]['inCpG'][1])
                 if 'inCpG' not in prob_res[feat][entry][seq_name]: prob_res[feat][entry][seq_name]['inCpG']=[[],0]
               else: 
                 prob_res[feat][entry][seq_name]['noCpG']=[prob]
                 prob_res[feat][entry][seq_name]['noCpG'].append(read_length)
                 prob_res[feat][entry][seq_name]['inCpG']=[[],0]
            else:
               prob_res[feat][entry][seq_name]['inCpG']=[[],0]
               prob_res[feat][entry][seq_name]['noCpG']=[[],0]
         prob_res[feat][entry]['length']=end - start
         prob_res[feat][entry]['start']=start
   logging.info("  "+str(datetime.now()))
   logging.info("End get_reads_per_feature\n")
   return prob_res

def parse_mod():
    logging.info("Opening pre-processed files")
    logging.info("  "+str(datetime.now()))
    mod_dic={}
    gc_pos_dic={}
    with open(path_dic["modif_folder"] + "Preprocessed_Table_mod", "r") as probfile:
       for line in probfile:
           line=line.rstrip()
           if line.startswith(">"):
              seqname=line[1:] 
           elif len(line) > 0:
              mod_dic[seqname]=[int(x) for x in line.split(",")]
    with open(path_dic["modif_folder"] + "Preprocessed_Table_pos") as posfile:
       for line in posfile:
           line=line.rstrip()
           if line.startswith(">"):
              seqname=line[1:]         
           elif len(line) > 2:
              gc_pos_dic[seqname]=[int(x) for x in line.split(",")]
    logging.info("  "+str(datetime.now()))
    logging.info("Preprocessed files read and processed\n")
    return mod_dic, gc_pos_dic

def extract_CpG_per_feature(features, CpG):
    '''
    Function to associate CpG to features
    CpG {name : [start, end], ...} such as {'CpG1':[1,912], 'CPG2':[1421, 2152], ...}

    features {'5gene': {'ENSACLG00000000003': [78636, 79235], 'ENSACLG00000000004': [85876, 85876],...}, '3gene': {'ENSACLG00000000002': [19687, 19687]}, '5mRNA': {'ENSACLT00000000003': [78636, 80433], 'ENSACLT00000000004': [79235, 83444],...}, '3mRNA': {'ENSACLT00000000002': [19687, 21573]}, 'CDS': {'ENSACLP00000000002': [19687, 21631], 'ENSACLP00000000003': [79235, 80801],...}
    '''
    logging.info("Starting extract_CpG_per_feature")
    logging.info("  "+str(datetime.now()))
    res_dic={}
    start_CpG={y[0]:x for x, y in CpG.items()}
    end_CpG={y[1]:x for x, y in CpG.items()}
    for feature in features:
        if feature not in res_dic:
           res_dic[feature]={}
        for entry in features[feature]:
           start = min(features[feature][entry])
           end = max(features[feature][entry])
           entry_length=end - start
           if entry_length!=0:
              res_dic[feature][entry]=[[start, end]]
              CpG_island_list=[start_CpG[x] for x in start_CpG.keys() if int(x) >= start and int(x) <= end]
              end_CpG_island_list=[end_CpG[x] for x in end_CpG.keys() if int(x) >= start and int(x) <= end]
              final_CpG_island_list=list(set(CpG_island_list+end_CpG_island_list))
              res_dic[feature][entry].append(final_CpG_island_list)
           elif feature == 'between': 
              '''
              This is to deal with the case where the between feature goes to the end of the chromosome.
              The gene_feature files I used  do not contain the position of the end of the chromosome... I had to extract them from the gff file
              at ref/fish/Astatotilapia_calliptera/fAstCal1.2/gff3/Astatotilapia_calliptera.fAstCal1.2.99.primary_assembly.*.gff3.gz
              '''
              end_chrom={'chr1':41162407,'chr2':38215696,'chr3':52512415,'chr4':33433079,'chr5':38678279,'chr6':41428020,'chr7':68397778,'chr8':25827708,'chr9':35913139,'chr10':34074121,'chr11':36676067,'chr12':38669361,'chr13':33145951,'chr14':39985354,'chr15':40222765,'chr16':35801853,'chr17':39448915,'chr18':35852588,'chr19':30863130,'chr20':31467755,'chr22':35011464,'chr23':43921804}
              res_dic[feature][entry]=[[start, end_chrom[prefix]]]
              CpG_island_list=[start_CpG[x] for x in start_CpG.keys() if int(x) >= start]
              end_CpG_island_list=[end_CpG[x] for x in end_CpG.keys() if int(x) >= start]
              final_CpG_island_list=list(set(CpG_island_list+end_CpG_island_list))
              res_dic[feature][entry].append(final_CpG_island_list)
    logging.info("  "+str(datetime.now()))
    logging.info("End extract_CpG_per_feature\n")
    return res_dic
        
def summary_prob(results_dic):
    '''
    This script will return 2 dictionaries:
    feature_entry summarize the data from each entry for each feature. The lists for 'inCpG' and 'noCpG' contains the sum of probability, the number of CG and the length of the feature.
     ex: {'5mRNA': {'ENSACLT00000000003': {'inCpG': [0, 0, 0], 'noCpG': [4872705, 38398, 27547]}, 'ENSACLT00000000010': {'inCpG': [93264, 688, 3250], 'noCpG': [2929664, 23017, 723986]}}, '3mRNA': {...}, ...} 
    summary_entry summarize the data per feature. ex: {'5mRNA': {'inCpG': [86020, 688, 7429], 'noCpG': [7796966, 61415, 612003]}, '3mRNA': {'inCpG': [0, 0, 0], 'noCpG': [3108491, 24510, 254628]}, 'CDS': {...}, ...}
    '''
    logging.info("Start summary_prob")
    logging.info("  "+str(datetime.now()))
    summary_entry={}
    feature_entry={}
    for feat in results_dic:
       feature_entry[feat]={}
       summary_entry[feat]={}
       for entry in results_dic[feat]:
          feature_entry[feat][entry]={}
          count_CG_noCpG=0
          sum_prob_noCpG =0
          len_noCpG=0
          count_CG_inCpG=0
          sum_prob_inCpG=0
          len_inCpG=0
          for read in results_dic[feat][entry]:
             if read != 'start' and read != 'length':
                if len(results_dic[feat][entry][read]['noCpG'][0]) > 0:
                   count_CG_noCpG += len(results_dic[feat][entry][read]['noCpG'][0])
                   sum_prob_noCpG += sum(results_dic[feat][entry][read]['noCpG'][0])
                   len_noCpG+= results_dic[feat][entry][read]['noCpG'][1]
                if len(results_dic[feat][entry][read]['inCpG'][0]) > 0:
                   count_CG_inCpG += len(results_dic[feat][entry][read]['inCpG'][0])
                   sum_prob_inCpG += sum(results_dic[feat][entry][read]['inCpG'][0])
                   len_inCpG+= results_dic[feat][entry][read]['inCpG'][1]
          if len(results_dic[feat][entry]) > 2:
             feature_entry[feat][entry]['noCpG']=[sum_prob_noCpG/(len(results_dic[feat][entry])-2), count_CG_noCpG /(len(results_dic[feat][entry])-2), len_noCpG/(len(results_dic[feat][entry])-2)]
             feature_entry[feat][entry]['inCpG']=[sum_prob_inCpG/(len(results_dic[feat][entry])-2), count_CG_inCpG/(len(results_dic[feat][entry])-2), len_inCpG/(len(results_dic[feat][entry])-2)]
          else:
             feature_entry[feat][entry]['noCpG']=[0, 0, 0]
             feature_entry[feat][entry]['inCpG']=[0, 0, 0]
          feature_entry[feat][entry]['start']=results_dic[feat][entry]['start']
          feature_entry[feat][entry]['length']=results_dic[feat][entry]['length']
       if 'length' in summary_entry[feat]:
           summary_entry[feat]['length']+=results_dic[feat][entry]['length']
       else:
           summary_entry[feat]['length']=results_dic[feat][entry]['length']
       #return average probability per feature
       summary_entry[feat]['noCpG']=[len(feature_entry[feat]), sum([feature_entry[feat][x]['noCpG'][0] for x in feature_entry[feat]]) / len(feature_entry[feat]), sum([feature_entry[feat][x]['noCpG'][1] for x in feature_entry[feat]])/len(feature_entry[feat]), sum([feature_entry[feat][x]['noCpG'][2] for x in feature_entry[feat]])/len(feature_entry[feat])]
       summary_entry[feat]['inCpG']=[len(feature_entry[feat]), sum([feature_entry[feat][x]['inCpG'][0] for x in feature_entry[feat]]) / len(feature_entry[feat]), sum([feature_entry[feat][x]['inCpG'][1] for x in feature_entry[feat]])/len(feature_entry[feat]), sum([feature_entry[feat][x]['inCpG'][2] for x in feature_entry[feat]])/len(feature_entry[feat])]
    logging.info("  "+str(datetime.now()))
    logging.info("End summary_prob\n")
    return summary_entry, feature_entry

def parse_CpGfile(name):
    logging.info("Opening CpG island file")
    logging.info("  "+str(datetime.now()))
    CpG_dic={}
    sumprob=0
    medianval=0
    for line in open(path_dic["CpG_file"] + "CpG_"+name, "r"):
        line=line.rstrip()
        dataline=line.split()
        CpG_dic[dataline[2]] = [int(dataline[0]), int(dataline[1])]
    logging.info("  "+str(datetime.now()))
    logging.info("CpG island file read and processed\n")
    return CpG_dic

#gene feature file
filename=sys.argv[1]

#get prefix for other files to process
prefix=filename.split("/")[-1].split("_")[0].replace("omosome","")
path_dic={}
#read config file
for line in open("process.config","r"):
    line=line.rstrip()
    dataline=line.split()
    path_dic[dataline[0]]=dataline[1]

logging.basicConfig(filename='process_'+prefix+'.log',  level=logging.DEBUG)

# read name of CpG_islands & position. The returned dictionary will be in this format: {CpG2865': [41143415, 41144464], ...
CpG_dic= parse_CpGfile(prefix)
# open the gene feature file. The returned format will be: {'5gene': {'ENSACLG00000000003': [78636, 79235],...}, '3gene': {'ENSACLG00000000002': [19687, 19687]}, '5mRNA': {'ENSACLT00000000003': [78636, 80433],...}, '3mRNA': {'ENSACLT00000000002': [19687, 21573]}, 'CDS': {'ENSACLP00000000002': [19687, 21631],...}
features_dic=parse_genefile(filename)
# associate the CpG to the features. Will return a nested dictionary: {features:{feature_name:[[feature_start, feature_end], [list of CpG islands]],...},...}
CpG_features_dic=extract_CpG_per_feature(features_dic, CpG_dic)
# get the probability and position for each CG position of the reads
mod_dic, pos_dic=parse_mod()
# extract the reads corresponding to each gene features from the sorted bam file and associate the probability for each CG in the feature (in and out of the CpG islands)
raw_results= get_reads_per_feature(CpG_features_dic, mod_dic, pos_dic, CpG_dic)
summary_results, feature_results=summary_prob(raw_results)

#formating and ordering
feature_order=['5gene', '5mRNA', 'CDS', '3mRNA', '3gene', 'between']
feature_eq={'5gene':'PROMOTER', '3gene':'END_GENE', 'CDS': 'CODING_REGIONS', '5mRNA': "5prime_UTR", '3mRNA': "3prime_UTR", 'between': "BETWEEN_GENES"}
logging.info("Generation of all features output files and bed files")
logging.info("  "+str(datetime.now()))
outputbed=open(path_dic["bed_folder"] + "Cm_"+prefix+".bed","w")
outputbed_inCpG=open(path_dic["bed_folder"] + "Cm_inCpG_"+prefix+".bed","w")
#will contain data in this format: chr   feat_start   feat_end   prob
bed_list=[]
bed_inCpG_list=[]
for feat in feature_order:
    output=open(path_dic["output_folder"] + prefix+"_CpG_"+feature_eq[feat]+"_results.tsv", "w")
    output.write("feature\tlength\tCm_noCpG\tnberCG_noCpG\tlength_noCpG\tCm_inCpG\tnberCG_inCpG\tlength_inCpG\n")
    outputsum=open(path_dic["output_folder"] + prefix+"_CpG_"+feature_eq[feat]+"_summary.tsv", "w")
    outputsum.write("feature\tlength\tCm_per_feature_length\tCm_noCpG_per_feature_length\tCm_inCpG_per_feature_length\n")
    #to ensure data are ordered by location on chromosome
    list_start_per_feat=[[feature_results[feat][x]['start'],x] for x in feature_results[feat]]
    sorted_list_per_feat=[x[1] for x in sorted(list_start_per_feat)]
    for featname in feature_results[feat]:
        startf=feature_results[feat][featname]['start']
        lengthf=feature_results[feat][featname]['length']
        output.write(featname+"\t"+str(lengthf)+"\t"+str(round(feature_results[feat][featname]['noCpG'][0],1))+"\t"+str(round(feature_results[feat][featname]['noCpG'][1],1))+"\t" + \
        str(round(feature_results[feat][featname]['noCpG'][2],1))+"\t"+str(round(feature_results[feat][featname]['inCpG'][0],1))+"\t" + \
        str(round(feature_results[feat][featname]['inCpG'][1],1))+"\t" + str(round(feature_results[feat][featname]['inCpG'][2],1))+"\n")
        cm_noCpG=0
        cm_inCpG=0
        if feature_results[feat][featname]['inCpG'][2] > 0:
            cm_noCpG=round(lengthf*(feature_results[feat][featname]['noCpG'][0]/feature_results[feat][featname]['noCpG'][2]),1)
        if feature_results[feat][featname]['inCpG'][2] > 0: 
            cm_inCpG =round(lengthf*(feature_results[feat][featname]['inCpG'][0]/feature_results[feat][featname]['inCpG'][2]),1)
        cm_all=round((cm_noCpG+cm_inCpG)/2,1)
        outputsum.write(featname+"\t"+str(lengthf)+"\t"+str(cm_all)+"\t"+str(cm_noCpG)+"\t"+str(cm_inCpG)+"\n")
        bed_list.append([startf, startf+lengthf -1, cm_all])
        bed_inCpG_list.append([startf, startf+lengthf -1, cm_inCpG])
    output.close()
    outputsum.close()
bed_list.sort()
bed_inCpG_list.sort()
for entry in bed_list:
    outputbed.write(prefix+"\t"+str(entry[0])+"\t"+str(entry[1])+"\t"+str(entry[2])+"\n")
outputbed.close()
for entry in bed_inCpG_list:
    outputbed_inCpG.write(prefix+"\t"+str(entry[0])+"\t"+str(entry[1])+"\t"+str(entry[2])+"\n")
outputbed_inCpG.close()
logging.info("  "+str(datetime.now()))
logging.info("All features output and bed files generated\n")

'''
summary_results example:
{'5gene': {'length': 1504, 'noCpG': [114, 47838.79863080806, 370.4022853982453, 24311.277824176566], 'inCpG': [114, 410.6960169274378, 5.555586100351444, 232.7148511234535]}, ...}
'''
output=open(path_dic["output_folder"] + prefix+"_feature_results.tsv", "w")
header_line=["feature", "total_number", "mean_length", "mean_prob", "mean_prob/length", "noCpG_mean_prob", "noCpG_mean_length", "noCpG_mean_CGcount", "features_with_CpG", "inCpG_mean_length", "inCpG_mean_CGcount"]
output.write("\t".join(header_line)+"\n")
logging.info("Generation of summary per feature")
logging.info("  "+str(datetime.now()))
for feat in feature_order:
   line=[feature_eq[feat]]
   #total number of features
   nbr_feat= summary_results[feat]['noCpG'][0]
   line.append(str(nbr_feat))
   #mean length of features
   total_length= summary_results[feat]['noCpG'][3] + summary_results[feat]['inCpG'][3]
   mlength=round(total_length/nbr_feat,1)
   line.append(str(mlength))
   #mean probability per feature (sum probability/nber of features)
   line.append(str(round((summary_results[feat]['noCpG'][1] + summary_results[feat]['inCpG'][1])/nbr_feat,1)))
   #mean probability per length
   line.append(str(round((summary_results[feat]['noCpG'][1] + summary_results[feat]['inCpG'][1])/(nbr_feat*mlength),1)))
   #mean probability of noCpG region per feature (sum probability noCpG/nber of features)
   line.append(str(round(summary_results[feat]['noCpG'][1] /nbr_feat,1)))
   #mean length of noCpG region per feature 
   line.append(str(round(summary_results[feat]['noCpG'][3] /nbr_feat,1)))
   #mean CG count in noCpG region per feature
   line.append(str(round(summary_results[feat]['noCpG'][2] /nbr_feat,1)))
   if summary_results[feat]['inCpG'][0] > 1:
       #mean probability of inCpG region per feature (sum probability inCpG/nber of features)
       line.append(str(round(summary_results[feat]['inCpG'][1] /nbr_feat,1)))
       #mean length of inCpG region per feature
       line.append(str(round(summary_results[feat]['inCpG'][3] /nbr_feat,1)))
       #mean CG count in inCpG region per feature
       line.append(str(round(summary_results[feat]['inCpG'][2] /nbr_feat,1))) 
   else: line=line+['0','0','0']
   output.write("\t".join(line)+"\n")
output.close()
logging.info("  "+str(datetime.now()))
logging.info("Feature level summary generated\n")
logging.info("----RUN COMPLETED----")
